package com.kobe.sort;

/**
 * 插入排序
 * 假定一组数字是 2、1、9、3、5
 * 一组n个数字组成的序列的两两节点对数 = (n*(n-1))/2。
 * 一组数字的有序度 = 已经两两有序的对数，示例中 = 6对(2--3，2--5，1--9，1--3，1--5，3--5)
 * 满序度=(n*(n-1))/2，示例中 = 10对
 * 逆序度 = 满序度 - 有序度
 * 交换次数 = 逆序度
 * 平均交换次数 = ((n*(n-1))/2 + 0)/2 = (n*(n-1))/4 = O(n^2)
 *
 * 插入排序 vs 冒泡排序 优劣分析
 * 元素交换次数：都是序列的逆序度
 * 元素交换步骤：冒泡排序的每次交换需要三步操作，而插入排序的交换只需要一步操作，
 * 因此插入排序比冒泡运行效率快点
 *
 * 0. 算法思路
 * - 从左到右遍历，把当前遍历节点的左边看做已排序区域，右边看做待排序区域。
 * - 当前节点需要在已排序区域找到一个正确的位置插入进去，从当前节点相邻的节点往
 * 第一个元素的方向遍历，跟每个节点比较，如果逆序则移动数据，直到不逆序位置，则插入进去
 *
 * 1. 时间复杂度：
 *      之最好情况 = O(n)
 *      之最坏情况 = O(n^2)
 *      之比较次数 =
 *      之交换次数 =
 * 2. 空间复杂度 = O(1)
 * 3. 空间复杂度之原地排序（是否是O(1)的空间复杂度） = true
 * 4. 排序稳定性（相等的两个值保持排序前的顺序） = true
 *
 *
 */
public class InsertSort {
    public static void sort(int[] arr) {
        if (arr == null) {
            return;
        }

        for (int i=1; i<arr.length; i++){
            int tmp = arr[i];
            int j=i-1;
            for (; j>=0; j--){
                if (arr[j] > tmp){
                    arr[j+1] = arr[j];
                } else{
                    break;
                }
            }
            arr[j+1] = tmp;
        }

    }
}
