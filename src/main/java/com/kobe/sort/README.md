## 排序算法比较
排序算法|平均时间复杂度|最坏时间复杂度|空间复杂度|排序稳定性|思路
---|---|---|---|---|---|
冒泡|O(n^2)|O(n^2)|O(1)|true|tbd
插入|O(n^2)|O(n^2)|O(1)|true|tbd
选择|O(n^2)|O(n^2)|O(1)|false|tbd
快排|O(n*lgn)|O(n^2)|O(1)|false|tbd
归并|O(n*lgn)|O(n*lgn)|O(n)|true|tbd
堆排序|O(n*lgn)|O(n*lgn)|O(1)|false|基于数组构建的二叉堆<br>依次删除堆顶(实际是把堆顶元素依次放到数组末尾)
桶排序|O(n)|O(n*lgn)|aa|true|tbd
计数|O(n+m)|O(n+m)|aa|true|tbd

## O(n*lgn)型排序：快排 vs 归并 vs 堆排序
- 【时间复杂度】这三种平均时间复杂度都是O(n*lgn)
- 【原地排序】归并不是原地排序，快排和堆排序是
- 【排序稳定性】归并排序是，快排和堆排序不是

#### 为什么快排优于堆排序？
堆排序的时间复杂度稳定在O(n*lgn)，快排在极端情况会退化成O(n^2)，为什么大部分情况不用堆排序？
- 堆排序在建堆过程中会打乱原有顺序，导致比快排更多的比较次数
- 堆排序的插入删除操作，沿着树方向移动，会间隔访问数字，对cpu缓冲不友好。而快排的操作过程都是顺序访问数据
- 堆排序只能用数组存储数据，而快排不限于数组，也可以用链表

## O(n)型线性排序：桶排序、计数排序、基数排序

## O(n)型线性排序 vs O(n*lgn)型排序
#### O(n)型线性排序的前提
- 不是原地排序，需要额外内存。
- 能对排序数据很容易划分区间
- 划分的区间内数据需要想到平衡，否则效率会退化成O(n*lgn)

#### O(n)型线性排序的适应场景
- 适合外部排序，即内存比要排序的数据量小




